1.-- 1. DJStudent 테이블 생성
--      학번, 이름, 학과명을 저장(모두 varchar2로 할 것)
CREATE TABLE DJStudent(
    SNUM VARCHAR2(20),
    SNAME VARCHAR2(20),
    SMJNAME VARCHAR2(20)
);
-- 2.   KBMajor 테이블 생성
--      학과코드(char(3)), 학과명(varchar2)
CREATE TABLE KBMajor(
    MCODE CHAR(3) PRIMARY KEY,
    MMJNAME VARCHAR2(100)
);
-- 3. KBStudent 테이블 생성
--      학번, 이름, 학과코드(char(3))
CREATE TABLE KBStudent (
    KSNUM  VARCHAR2(20),
    KSNAME VARCHAR2(100),
    KSCODE CHAR(3) PRIMARY KEY
);
--1,2,3에 각각 예시 데이터 5개 이상 추가하기
-- DJStudent 데이터 추가
INSERT INTO DJStudent VALUES('1','이현오','전자공학');
INSERT INTO DJStudent VALUES('2','이우성','컴퓨터공학');
INSERT INTO DJStudent VALUES('3','김유정','전기공학');
INSERT INTO DJStudent VALUES('4','박종학','기계공학');
INSERT INTO DJStudent VALUES('5','김건호','건축공학');

-- KBMajor 데이터 추가
INSERT INTO KBMajor VALUES('A','전자공학');
INSERT INTO KBMajor VALUES('B','컴퓨터공학');
INSERT INTO KBMajor VALUES('C','전기공학');
INSERT INTO KBMajor VALUES('D','기계공학');
INSERT INTO KBMajor VALUES('E','건축공학');
-- KBStudent 데이터 추가
INSERT INTO KBStudent VALUES('11','이순신','A');
INSERT INTO KBStudent VALUES('12','임꺽정','B');
INSERT INTO KBStudent VALUES('13','유관순','C');
INSERT INTO KBStudent VALUES('14','이이','D');
INSERT INTO KBStudent VALUES('15','곽재우','E');

SELECT * FROM DJStudent;
SELECT * FROM KBMajor;
SELECT * FROM KBStudent; -- 외래키 추가함 참고할 테이블은 KBMajor CODE

DROP TABLE KBMAJOR;
ALTER TABLE KBStudent ADD CONSTRAINT FK_CODE FOREIGN KEY(KSCODE) REFERENCES KBMajor(MCODE);

INSERT INTO KBSTUDENT VALUES('4','김동하','AB'); -- OK
INSERT INTO KBSTUDENT VALUES('5','박정후','111'); -- 학과코드가 111인 과는 현재 없다

INSERT INTO KBMAJOR VALUES('004','경영');
INSERT INTO KBSTUDENT VALUES('16','권대한','004');

-- JOIN
-- 두 개 이상의 테이블을 공통된 열(COLUMN)으로 묶는다
SELECT KSNUM,KBSTUDENT.KSNAME,KBMAJOR.MMJNAME
FROM KBSTUDENT JOIN KBMAJOR
ON kbstudent.kscode =kbmajor.mcode;

SELECT KSNUM 학번,KBSTUDENT.KSNAME 학생이름,KBMAJOR.MMJNAME 학과명
FROM KBSTUDENT JOIN KBMAJOR
ON kbstudent.kscode =kbmajor.mcode;

-- WHERE을 사용한 JOIN문, 두 테이블을 콤마,로 묶고, WHERE문을 사용함
SELECT KSNUM 학번,KBSTUDENT.KSNAME 학생이름,KBMAJOR.MMJNAME 학과명
FROM KBSTUDENT, KBMAJOR
WHERE kbstudent.kscode =kbmajor.mcode;

COMMIT;

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
2.

-- SINGER 테이블 생성 순번id 정수 순차적증가, 이름name 최대 10글자
--                  , 히트곡hit_song_id 정수 단히트곡은 song테이블의 _id에 영향받음
CREATE TABLE SINGER (
    id INT, -- 순번
    name VARCHAR2(30), --이름
    hit_song_id INT -- 히트곡 FK
);  
-- SONG  테이블 생성 순번id 정수 순차적증가, 노래제목title 최대20글자,절때 빈칸x
--                  가격price 정수
CREATE TABLE SONG(
    id int PRIMARY KEY, --순번
    title VARchar2(60) NOT NULL, -- 노래제목
    price INT   -- 가격
);
DROP TABLE SONG;

-- 각 테이블 데이터 추가
-- SINGER 테이블 데이터 추가
INSERT INTO SINGER VALUES(1,'소녀시대', 1);
INSERT INTO SINGER VALUES(2,'원더걸스', 2);
INSERT INTO SINGER VALUES(3,'동방신기', 3);

-- SONG 테이블 데이터추가
INSERT INTO SONG VALUES(1,'GEE',10000);
INSERT INTO SONG VALUES(2,'TELL ME',9000);
INSERT INTO SONG VALUES(3,'HUG',8000);
INSERT INTO SONG VALUES(4,'거짓말',7000);
INSERT INTO SONG VALUES(5,'촛불',5000);

-- FK 설정
ALTER TABLE SINGER ADD CONSTRAINT FK_CODE FOREIGN KEY(HIT_SONG_ID)
REFERENCES SONG(ID);

-- 결과를 join으로 출력
SELECT SINGER.ID, NAME, TITLE, PRICE FROM SINGER JOIN SONG 
ON singer.hit_song_id = song.id;

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
3.-- 각자의 이름과 보스의 이름을 같이 출력할것 
-- 단 최상위층일 경우는 보스 이름에 자기 자신을 출력한다.

CREATE SEQUENCE SAMSUNGPERSON;

-- samsungpeople 테이블 생성
CREATE TABLE MYSAMSUNGPEOPLE (
    ID INT PRIMARY KEY,
    NAME VARCHAR2(30) NOT NULL,
    BOSS_ID INT
);

INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '이건희', SAMSUNGPERSON.CURRVAL);

SELECT * FROM MYSAMSUNGPEOPLE;

INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '홍라희', SAMSUNGPERSON.CURRVAL);
INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '이부진',1 );
INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '이재용',1 );
INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '신라호텔',3);
INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '삼성전자', 4);
INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '수원삼성', 4);
INSERT INTO MYSAMSUNGPEOPLE VALUES
(SAMSUNGPERSON.NEXTVAL, '삼성라이온즈', 4);

COMMIT;
rollback;
drop table mysamsungpeople;
drop SEQUENCE samsungperson;
-- self join
SELECT b.name 이름, a.name 보스 FROM MYSAMSUNGPEOPLE a JOIN MYSAMSUNGPEOPLE b ON a.ID=b.BOSS_ID;

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
4.create sequence mymusic;
--drop table djsong;
create table djsong
( id int primary key,
title varchar2(60) not null, --최대 20글자, 절대 빈 칸 일 수 없음
price int);

--최대 20글자 = nvarchar2(20)
-- nvarchar나 nchar 없이 이 조건을 만족하려면 varchar2(60)을 해야 함
-- 한글은 1글자당 3byte이므로 이렇게 한다.
-- nvarchar nchar이거를 지원하지 않는 dbms도 있고
-- 통상적으로 가~~~장 많이 쓰이는 게 varchar이므로 안 쓴다.

insert into djsong values(mymusic.nextval, 'Gee', 5000);
insert into djsong values(mymusic.nextval, 'Tell Me', 6000);
insert into djsong values(mymusic.nextval, 'Hug', 5500);
insert into djsong values(mymusic.nextval, '거짓말', 7500);
insert into djsong values(mymusic.nextval, '촛불', 9500);
insert into djsong values(mymusic.nextval, 'Love Lee', 10000);

select * from djsong;

create sequence mysinger;
-- id int default mysinger.nextval primary key
-- id를 입력하지 않으면 알아서 1번부터 하나씩 증가한다.
--nextval이라는 것과 currval이라는 것이 있다.
-- nextval = 값을 주고 그 값을 증가시킴
-- currval = 값을 주기만 함
create table djsinger (
id int default mysinger.nextval primary key,
name varchar2(30),
hit_song_id int,
CONSTRAINT fk_hit foreign key (hit_song_id) references djsong(id)
);

insert into djsinger(name, hit_song_id) values ('소녀시대',1);
insert into djsinger(name, hit_song_id) values ('원더걸스',2);
insert into djsinger(name, hit_song_id) values ('동방신기',3);
insert into djsinger(name, hit_song_id) values ('AKMU',6);

insert into djsinger(name, hit_song_id) values ('이동준',100); --song id가 100인 노래가 없음

select * from djsong;
select * from djsinger;

select djsinger.name 가수이름, djsong.title 히트곡이름 from djsinger join djsong 
on djsinger.hit_song_id = djsong.id;

--join도 여러 종류가 있음
-- left join, right join, full join이 있음
-- 일반적인 join은 inner join이라고 함
-- inner join의 경우에는 공통된 값, 그러니까 둘 다 존재하는 것만 표시해줌

--right join의 경우 오른쪽 테이블에 있는 데이터들은 무조건 다 출력함
select djsinger.name 가수이름, djsong.title 히트곡이름 from djsinger right join djsong 
on djsinger.hit_song_id = djsong.id;

insert into djsinger(name) values('이동준');

--left join의 경우 왼쪽 테이블에 있는 데이터들은 무조건 다 출력함
select djsinger.name 가수이름, djsong.title 히트곡이름 from djsinger left join djsong 
on djsinger.hit_song_id = djsong.id;

-- 전부 다 보여줌(왼쪽, 오른쪽 전부)
select djsinger.name 가수이름, djsong.title 히트곡이름 from djsinger full join djsong 
on djsinger.hit_song_id = djsong.id;


select * from djsong;
delete from djsong where id=9;
--시퀀스 값 바꾸는 법
--1. 지운다.
drop sequence mymusic;
--2. 새로 만들되, 내가 시작하고 싶은 번호부터 시작하도록 한다.
create sequence mymusic start with 7 increment by 1;


-- || : 문자열 이어붙이기(java에서 +로 문자열 이어붙인 거랑 똑같음)
insert into djsong values(mymusic.nextval, 'You' || '&' || 'Me', 12000);
select mymusic.currval from dual; 
insert into djsong values(mymusic.nextval, 'Super Shy', 15000);

delete from djsong where title='Super Shy';
select * from djsong;

insert into djsong values(mymusic.nextval, '호랑나비', 9000);
select mymusic.currval from dual;

drop SEQUENCE mymusic;
create sequence mymusic start with 8 increment by 1;
delete from djsong where title='호랑나비';
insert into djsong values(mymusic.nextval, '호랑나비', 9000);

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
5.-- 뷰(VIEW)
-- 뷰의 기본용도가 데이터를 보기 위함이다
-- 가상테이블
-- 기본적인 삭제 수정 삽입은 안되고(= 복잡한구조에는 불가능하고 단순한 구조에는 가능)
-- 대신 원본이 바뀔시 VIEW 값도 바뀐다
-- VIEW = SELECT 결과물
-- SELECT문이 너무 복잡해지거나 혹은 자주 쓰이는 SELECT문을 더 편하게 불러오고자 쓰는 것

CREATE VIEW MYSTUDENT AS
SELECT KBSTUDENT.KSNAME NAME, KBMAJOR.MMJNAME MAJ_NAME FROM KBSTUDENT
JOIN KBMAJOR ON KBSTUDENT.KSCODE = KBMAJOR.MCODE;

SELECT * FROM MYSTUDENT; -- MYSTUDENT는 실제 값이 아니다
    -- KBSTUDENT, KBMAJOR로 만들어진 가상의 표(SELECT 결과물)
    -- DELETE, UPDATE,INSERT가 단순한 구조의 VIEW에서는 되는데 복잡한 구조의 VIEW에선 안 됨
DELETE FROM MYSTUDENT WHERE MAJ_NAME = '경영';
SELECT * FROM KBSTUDENT;

INSERT INTO KBSTUDENT VALUES(2,'유지웅','002');

-- VIEW를 통해서 SELECT문을 단순화하고 보다 복잡한 형태의 JOIN등도 구현이 가능함


-- 순서대로 출력하는 것
--...순으로 출력하는 것 : ORDER BY
SELECT * FROM KBSTUDENT;
SELECT * FROM KBSTUDENT ORDER BY KSNUM; -- 오름차순
SELECT * FROM KBSTUDENT ORDER BY KSNUM DESC; -- 내림차순

-- 그룹 별로 출력하는 것(GROUP BY,HAVING)
-- EX 학생이 100명있다
-- 남학생 N명 여학생 M명 있을때 학생별로 평균 나이 등을 구하는 것을 그룹별로 묶는다라고 함

-- KBSTUDENT로 예를 들면 학과별로 몇명 있는지 출력 해볼수있다
-- 만약 KBSTUDENT에 나이 정보가 있었다면 학과별로 평균 나이등도 구할 수 있을 것이다.
SELECT KSCODE,COUNT(*)FROM KBSTUDENT GROUP BY KSCODE;

-- VIEW 사용하기
-- COUNT(*) : 행의 수 (ROW 개수)
SELECT MAJ_NAME,COUNT(*)FROM MYSTUDENT GROUP BY MAJ_NAME;

-- GROUP BY용 WHERE절이 있는데 바로 HAVING절
-- GROUP BY에서만 사용가능한 WHERE절
-- 학과별 각각 몇명있는지 구하고 그중에서 1명을 넘는 과만 출력하라
SELECT MAJ_NAME,COUNT(*)FROM MYSTUDENT GROUP BY MAJ_NAME HAVING COUNT(*)>1;

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7.CREATE SEQUENCE COMPANY;
--1. 부서 테이블 생성
-- 코드 char(3)
-- 부서명 varchar2(100)
CREATE TABLE DEPARTMENT(
    D_CODE CHAR(3) PRIMARY KEY,
    D_NAME VARCHAR2(100)
);
--2. 직급 테이블 생성
-- 코드 int
-- 직급명 varchar2(100)
CREATE TABLE RANK(
    R_CODE INT PRIMARY KEY,
    R_NAME VARCHAR2(100)
);
--3. 인사 테이블을 만든다.
-- 사번 char(5)
-- 부서코드
-- 직급코드
-- 이름 varchar2(100)
-- 나이 int
-- 성별 char(1)
-- HP varchar2(15) unique
CREATE TABLE TRANSFER(
    T_NUM CHAR(5),
    TD_CODE CHAR(3),
    TR_CODE INT,
    T_NAME VARCHAR2(100),
    T_AGE INT,
    T_SEX CHAR(1),
    T_HP VARCHAR(15) UNIQUE
);

--4. 부서 3개, 직급 3개, 사람 10명을 만든다.
--부서 3개
INSERT INTO DEPARTMENT VALUES('111','도시과');
INSERT INTO DEPARTMENT VALUES('222','환경과');
INSERT INTO DEPARTMENT VALUES('333','경제과');
--직급 3개
INSERT INTO RANK VALUES(COMPANY.NEXTVAL,'주임');
INSERT INTO RANK VALUES(COMPANY.NEXTVAL,'과장');
INSERT INTO RANK VALUES(COMPANY.NEXTVAL,'부장');
--사람 10명
INSERT INTO TRANSFER VALUES('A','111',1,'이현오',32,'M','010-1111-1111');
INSERT INTO TRANSFER VALUES('B','333',2,'박주호',26,'M','010-2222-2222');
INSERT INTO TRANSFER VALUES('C','222',3,'이기현',29,'F','010-3333-3333');
INSERT INTO TRANSFER VALUES('D','111',3,'김상수',36,'M','010-4444-4444');
INSERT INTO TRANSFER VALUES('E','222',2,'장덕수',40,'M','010-5555-5555');
INSERT INTO TRANSFER VALUES('F','222',1,'정민호',38,'M','010-6666-6666');
INSERT INTO TRANSFER VALUES('G','333',2,'조민우',33,'M','010-7777-7777');
INSERT INTO TRANSFER VALUES('H','333',3,'강대호',41,'M','010-8888-8888');
INSERT INTO TRANSFER VALUES('I','111',2,'나유라',21,'F','010-9999-9999');
INSERT INTO TRANSFER VALUES('J','111',1,'문성후',38,'M','010-0000-0000');

--5. 성이 이씨인 사람을 찾는 쿼리를 작성(like 혹은 구글링이나 gpt 쓰기)
SELECT * FROM TRANSFER WHERE T_NAME LIKE '이%';    

--6. 가장 많은 나이는 몇 살인지 출력
SELECT MAX(T_AGE)||'살' FROM TRANSFER ;
--7. 가장 나이가 어린 사람은 누구인지 출력(중첩질의문을 쓰면 되는 데 무슨 말인지 모르면 구글링이나 gpt)
SELECT T_NAME FROM TRANSFER WHERE T_AGE = (SELECT MIN(T_AGE) FROM TRANSFER);
--8. 가장 나이가 많은 부서 차기(평균 나이 기준)

--9 성별별 평균 나이 출력하기

--10. 인사 테이블을 출력하되, 부서코드와 직급코드들도 부서명과 직급명으로 출력하기
--      즉 3개의 테이블을 서로 조인해야 함

객체를 생성 해서 작동 하기에 객체 지향형 언어 이다
코드 한줄씩 리뷰하고 한줄당 주석 달아야 한다
분해 해석을 잘 해야함 분해 하는 기준은 동사 형
틀부터 미리 만들어 놓고 대괄호{} 는 절때 지우지 마라
지우려면 쌍으로 지워야 함
바깥쪽 초기화 할 경우 안쪽도 초기화 해주는 게 알고리즘 상 해주는게 좋다
자바는 카멜표기법

ctrl + d 한줄 복사
ctrl + w 한단어 한줄 드래그
ctrl + alt L 정리 
ctrl + r 검색해서 전체 수정 replace all
ctrl / 한 줄 주석, ctrl + shift /
shif f6 클래스 명 바꾸기
F9 다음 BP까지 실행
F8 디버깅 한줄씩 실행
F7 함수 안으로 들어가기
Alt + insert 생성자 생성, getter setter 생성

double num2 = -1;             실수
String num3 = "a";             문자열
boolean num4 ;               참 , 거짓
long을 int로 형 변환은 어렵다
str.equals() 문자열 비교할때 사용
this.변수는 그 메소드안에서 사용한다는 말이고 멤버변수라는걸 정의해줘야한다
extends	상속 하기위해 클래스에 쓴다
super	상속되어있는 하위클래스에 상위클래스에서 참조해온다 
inplements 인터페이스 구현하는 클래스에 쓴다

객체 == 설계도 클래스를통해 현실화됌
객체 한테 무슨 일을 시킬 때는 메소드(기능,동사)를 사용

클래스 == 설계도의 개념 자기자신혼자만생각 각각클래스는 별개다.  
  // 최상위 클래스 == object 클래스
  // 클래스 명은 항상 대문자 로 시작
  // 클래스는 스펙과 기능을 가지고 있다
  // 스펙 명사=변수 기능 동사=메소드
  // 고로 클래스는 변수와 메소드(함수)를 가지고 있다.
  // 클래스 안의 변수는 멤버변수 필드라고 불린다
  // 클래스 안의 변수는 데이터 값이 없다!
  // 상위클래스 일수록 러프 , 하위클래스 일수록 세분화 된다.

생성자 == 객체가 생성될때 딱 한번만 호출되고 독립적으로 사용불가
특수한 정의를 하고싶을때 생성해서 만든다

상수(constants)
 // 변수를 선언할 때 그 앞에 final 키워드 추가
 // 값을 딱 한번만 할당 하고 변경 불가능하다
 // 상수의 이름은 대문자로 작성한다

형변환
System.out.println((double) num1 / num2) 출력앞에 (형태)를 적어준다

입력
 받기 위한 객체 선언 , 입력을 받고 나면 무조건 스트링(문자)가 된다
   Scanner scanner = new Scanner(System.in);
   String str = scanner.nextLine();    // nextLine();한줄씩 입력 받는다
   int input = Integer.parseInt(str);  // 문자 데이터를 숫자 데이터로 변환해준다
    // parse 자주 보이는데 mapping 역활이다
    // mapping 은 형태를 바꿔서 맞춰 준다 의미

출력
  // sout (" " + )로사용하면된다 +는 앞에와도댐

조건문
 // if ~ else if 는 출력이 되던 안되던 상관없다
 // if ~ else 는 무조건 출력이 되어야한다 다중택일

오버로딩 : (함수에 적용되는 개념)
    매개변수 구성이 다르다면, 함수명을 같게 하여도 함께 사용할 수 있다.

메소드 == 클래스안의 기능들 동사형
  // 돌려줄땐 주로 get 많이쓴다
  // 리턴 값은 한개만 가능하다
  // 다수를 리턴하기 위해서는 클래스를 리턴해서 하면된다
  // 메소드 오버라이딩 @Override== 어노테이션이다 super.상위클래스메소드
 	 // 상위 클래스에 정의된 메소드를 하위 클래스에서 재정의 가능
getter setter 
단순하게 값을 얻어오고 셋팅할때 사용한다

멤버변수 == 클래스안에서 사용가능한 

패키지 == 한묶음이라 생각하면 될 듯
다론 폴더 안에 있을	땐 사용 불가능한데
include 역활 즉 Alt + Enter import가 추가해서 쓰면 가능해진다
아니면 같은폴더에 넣으면됌 

상속 == 확장하는 개념, is a kind of 종류
하위 클래스는 상위 클래스의 모든 특성 보유
하위 클래스는 자신만의 추가적인 특성 확장

인터페이스==형태
// 껍데기만 제공한다
// 선언만 함(추상 메소드만 담고 있다)
// 다중 상속이 가능하다
// 인터페이스명에는 able이 많이 붙는다

  // 인터페이스 구현 하는 곳
  // implements 
  // 구현 하는 곳의 접근지시자는 전부 public
  // 무조건 비어 있어도 인터페이스에 있는 메소드를 정의 해줘야 함
  // 무조건 오버라이딩 해서 정의

JSP
// java,C 등 언어 백앤드를 프론트엔드html 등으로
   넘겨줄때 쓰는거 mvc2 model

컬렉션 프레임워크
프레임워크 단일목적 
// 자료구조 : 데이터의 저장과 관련된 학문 탐색 삭제 데이터의 효율적 저장방법 연구
  Stack(선입후출: 먼저입력되고 제일 마지막에 출력된다) 
  Queue(선입선출) 
        JSP에 많이사용되는 두개
  Map(Tree,Hash) key로 값을 가져온다
  list index로 값 가져온다 

//알고리즘 : 저장된 데이터의 일부 전체를 대상으로 하는 각종 가공 및 처리방법연구
  (Bubble Sort
   Quick Sort 
   Binary Search)

(1)List<E> 
// 인터페이스를 구현하는 대표적인 컬렉션 클래스
// <>안에들어가야하는건 제네릭이다
   제네릭도 같은 타입이 들어가야 한다
   클래스만 들어갈수있다. 

// 래퍼클래스 
ex) Interger num = 1;  num은 객체이므로 값에 Null을 넣을수잇다
   정수형 Integer  
            Long
   실수형 Double
   Boolean
   문자형 String

// <1>ArrayList<>(); <>안에 비어있으면 앞의 <>를 쓴다 
           배열을 기반으로 인스턴스를 저장하므로 배열과 특성이 거의 유사
           1. 객체.add() 인덱스값에 추가
           2. 객체.get() 인덱스값에서 가져오기
           3. 객체.size() 인덱스값 크기 == C에서 sizeof
           잘안씀
           4. 객체.remove() 인덱스값 제거 

(2)Map<K, V> 순서가없다(마음대로 지정가능)
// <1> Hashmap<Key,Value>
   K값은 웬만해서 String으로 쓰는게 알기쉽다
   같은 K에 V대입시 덮어쓰기된다
   V값에 Object를 쓰면 전부 포함가능하다
     왜냐면 Object는 최상위 클래스니깐 하위 클래스를 포함할수있으니깐
    대신 출력할때는 형변환해서 맞춰 줘야한다.

   1. 객체.put(Key값,Value) K에 V 저장
   2. 객체.get(Key) K값 가져오기
   3. 객체.remove(Key) K에 저장


플래그 세우기 적절하게 킬링 포인트로 사용해야한다 많이쓰면 힘들어진다

예외처리 어려운데 잘해야한다 그래야 개발을 잘하는것임
